<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tr√°i tim h·∫°t - Ch√∫c m·ª´ng 20/10</title>
<style>
  html,body{height:100%;margin:0;background:#070007;overflow:hidden;font-family:Segoe UI, Poppins, sans-serif}
  canvas{display:block;position:fixed;left:0;top:0}
  .label{
    position:fixed;left:50%;bottom:6%;transform:translateX(-50%);
    color:#ffd6f8;font-size:24px;text-shadow:0 0 12px #ff8bd6,0 0 28px rgba(255,120,200,0.25);
    pointer-events:none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="label">üíê Ch√∫c m·ª´ng ng√†y 20/10 üíê</div>

<script>
/* Particle fountain ‚Üí heart cloud
   - Particles spawn near bottom pool, shoot up, get attracted to heart targets
   - When many particles at target => dense heart (like image)
   - Some particles miss & fall back to pool, creating ripple/pool effect
*/

const c = document.getElementById('c');
const ctx = c.getContext('2d', { alpha: true });
let W = c.width = innerWidth, H = c.height = innerHeight;

addEventListener('resize', ()=>{ W = c.width = innerWidth; H = c.height = innerHeight; buildTargets(); });

/* ================= heart parametric positions (filled area) ================= */
function heartXY(t){
  const x = 16 * Math.pow(Math.sin(t),3);
  const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
  return {x,y};
}

// Build target grid inside heart (dense)
let targets = [];
function buildTargets(){
  targets = [];
  // scale based on min dimension
  const scale = Math.min(W, H) / 90; // tweak for size
  // sample param t across [0,2pi) and also create interior points
  const outline = [];
  const samples = 600;
  for(let i=0;i<samples;i++){
    const t = (i/samples)*Math.PI*2;
    const p = heartXY(t);
    outline.push({x: p.x*scale, y: -p.y*scale});
  }
  // create interior by lerping outline to center
  for(let i=0;i<1200;i++){
    const s = outline[Math.floor(Math.random()*outline.length)];
    const shrink = 0.4 + Math.random()*0.9; // 0.4..1
    targets.push({ x: s.x*shrink, y: s.y*shrink });
  }
  // center offset so heart is above mid (raise a bit)
  const cx = W/2, cy = H*0.36;
  for(let p of targets){ p.x += cx; p.y += cy; }
}
buildTargets();

/* ================= particles ================= */
const particles = [];
const POOL_Y = H - 40; // pool vertical spawn area
const MAX_PARTICLES = 1800;

class P {
  constructor(){
    // spawn in pool area with small random x near center bottom band
    this.reset();
  }
  reset(){
    this.x = W/2 + (Math.random()-0.5) * (W*0.15);
    this.y = POOL_Y + Math.random()*20 + 10;
    // initial upward velocity (fountain)
    this.vx = (Math.random()-0.5)*1.6;
    this.vy = - (3 + Math.random()*4.5);
    this.size = 0.9 + Math.random()*1.8;
    this.alpha = 0; // for fade in
    this.life = 0;
    this.ttl = 6 + Math.random()*6;
    // choose target index sometimes, else wander
    this.target = null;
    if(Math.random() < 0.85) {
      // pick a near-target (so many will join heart)
      this.target = targets[Math.floor(Math.random()*targets.length)];
    }
    // color: purple-pink-white mix
    const hue = 280 + Math.random()*30; // 280-310 purple
    const light = 50 + Math.random()*30;
    this.color = `hsla(${hue},90%,${light}%,`;
    // small wobble for sparkle
    this.wob = (Math.random()-0.5)*0.8;
  }
  update(dt){
    this.life += dt;
    // gravity pulling some back
    this.vy += 0.03 * dt;
    // attraction to target when close to top of trajectory
    if(this.target){
      // compute vector to target, but only start attraction when y < target.y + margin
      const tx = this.target.x, ty = this.target.y;
      const ay = (ty - this.y);
      const ax = (tx - this.x);
      const d2 = ax*ax + ay*ay;
      // stronger attraction when near (smaller d2)
      const strength = Math.max(0, 0.0025 * (2 + (1e5/(1e2 + d2))));
      this.vx += ax * strength * dt + (Math.random()-0.5)*0.02;
      this.vy += ay * strength * dt + (Math.random()-0.5)*0.02;
    } else {
      // little drift
      this.vx += (Math.random()-0.5)*0.02;
    }

    // update pos
    this.x += this.vx * dt * 0.7;
    this.y += this.vy * dt * 0.7;

    // alpha fade in/out
    if(this.alpha < 1) this.alpha += 0.04 * dt;
    if(this.life > this.ttl) this.alpha -= 0.02 * dt;

    // if fallen below pool -> reset
    if(this.y > H + 50 || this.alpha <= 0) this.reset();
  }
  draw(ctx){
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = this.color + (0.6*this.alpha) + ')';
    // glow
    ctx.shadowBlur = 10 + Math.random()*15;
    ctx.shadowColor = '#ffb0ff';
    ctx.globalAlpha = Math.max(0.06, this.alpha * 0.95);
    ctx.arc(this.x, this.y, this.size*(1 + Math.random()*0.6), 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha = 1;
  }
}

/* spawn interval */
let spawnAcc = 0;
function spawn(dt){
  // adapt spawn rate with screen size
  const rate = Math.min(120, Math.floor(W/8)); // per second-ish
  spawnAcc += dt * rate;
  while(spawnAcc > 1){
    if(particles.length < MAX_PARTICLES) particles.push(new P());
    spawnAcc -= 1;
  }
}

/* pool ripple effect (simple) */
function drawPool(ctx){
  const grd = ctx.createRadialGradient(W/2, POOL_Y+12, 10, W/2, POOL_Y+12, 220);
  grd.addColorStop(0, 'rgba(255,160,230,0.18)');
  grd.addColorStop(1, 'rgba(10,4,20,0.0)');
  ctx.fillStyle = grd;
  ctx.beginPath();
  ctx.ellipse(W/2, POOL_Y+12, Math.min(W*0.25, 220), 30, 0, 0, Math.PI*2);
  ctx.fill();
  // some reflective particles on pool
  for(let i=0;i<80;i++){
    const x = W/2 + (Math.random()-0.5)*Math.min(W*0.24,220);
    const y = POOL_Y + 6 + Math.random()*10;
    ctx.fillStyle = `rgba(255,230,255,${0.02 + Math.random()*0.06})`;
    ctx.beginPath();
    ctx.arc(x,y, Math.random()*1.6,0,Math.PI*2);
    ctx.fill();
  }
}

/* main loop */
let last = performance.now();
function loop(now){
  const dt = Math.min(1/30, (now - last)/16.666); // normalized ~1 per frame
  last = now;

  // fade background slightly to produce motion blur trail
  ctx.fillStyle = 'rgba(2,1,6,0.22)';
  ctx.fillRect(0,0,W,H);

  // subtle starfield behind
  // draw a few faint sparkles
  for(let i=0;i<5;i++){
    ctx.beginPath();
    const sx = Math.random()*W;
    const sy = Math.random()*H*0.6;
    const r = Math.random()*0.9;
    ctx.fillStyle = `rgba(255,255,255,${0.02 + Math.random()*0.06})`;
    ctx.arc(sx,sy,r,0,Math.PI*2);
    ctx.fill();
  }

  // spawn particles
  spawn(dt);

  // draw particles sorted by y for depth (simple painter's algorithm)
  particles.sort((a,b)=> a.y - b.y);
  for(let p of particles){ p.update(dt); p.draw(ctx); }

  // draw brighter outline/heart-edge by boosting particles near target boundary
  // optional: draw faint white shell by sampling targets density:
  // We'll draw a soft bright outline from targets
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.beginPath();
  for(let i=0;i<targets.length;i+=6){
    const t = targets[i];
    // draw small glowing point
    ctx.fillStyle = 'rgba(255,245,255,0.06)';
    ctx.shadowBlur = 18;
    ctx.shadowColor = '#ffd6ff';
    ctx.beginPath();
    ctx.arc(t.x, t.y, 1.6 + Math.random()*1.6, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // small bloom/glow on heart center if many particles formed (count near center)
  // simple heuristic: count particles within a radius
  let near = 0;
  const cx = W/2, cy = H*0.36;
  for(let p of particles){
    const dx = p.x - cx, dy = p.y - cy;
    if(dx*dx + dy*dy < (Math.min(W,H)/7)*(Math.min(W,H)/7)) near++;
  }
  if(near > targets.length*0.08){
    // draw bright bloom
    const rad = Math.min(W,H)/4;
    ctx.beginPath();
    const g = ctx.createRadialGradient(cx,cy,10,cx,cy,rad);
    g.addColorStop(0,'rgba(255,210,255,0.16)');
    g.addColorStop(0.4,'rgba(255,160,220,0.06)');
    g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(cx - rad, cy - rad, rad*2, rad*2);
  }

  // draw pool
  drawPool(ctx);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// restart formation on click: reassign targets (re-sample)
window.addEventListener('click', ()=>{
  buildTargets();
  for(let p of particles){
    if(Math.random()<0.9) p.target = targets[Math.floor(Math.random()*targets.length)];
  }
});

// initial burst: prefill some particles to make effect immediate
for(let i=0;i<600;i++){ particles.push(new P()); }
</script>
</body>
</html>
