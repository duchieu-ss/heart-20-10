<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ch√∫c m·ª´ng 20/10 ‚Äî Tr√°i tim hoa</title>
<style>
  :root{
    --bg1:#070008;
    --bg2:#0b0010;
    --text:#ffd6f0;
  }
  html,body{
    height:100%;
    margin:0;
    background: radial-gradient(circle at 30% 20%, #0b0018 0%, var(--bg1) 30%, var(--bg2) 100%);
    font-family: "Poppins", system-ui, sans-serif;
    overflow:hidden;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    color:var(--text);
  }

  canvas{ position:fixed; inset:0; z-index:0; display:block; }

  .overlay{
    position:relative;
    z-index:2;
    text-align:center;
    pointer-events:none;
  }

  h1{
    margin:0;
    font-size:2.2rem;
    letter-spacing:1px;
    color:var(--text);
    text-shadow: 0 0 18px rgba(255,160,220,0.9), 0 0 36px rgba(255,100,180,0.5);
  }

  .sub{
    margin-top:12px;
    color: rgba(255,180,210,0.9);
    font-size:1rem;
    text-shadow: 0 0 10px rgba(255,120,200,0.4);
  }

  /* little shimmer on heart center while formed */
  .glow {
    position:absolute;
    width:260px;
    height:260px;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    border-radius:50%;
    filter:blur(40px);
    background: radial-gradient(circle at 40% 35%, rgba(255,140,200,0.45), rgba(255,80,160,0.18) 35%, transparent 60%);
    z-index:1;
    pointer-events:none;
    mix-blend-mode:screen;
    opacity:0;
    transition:opacity .8s;
  }

  /* small hint text for mobile */
  .hint{
    margin-top:14px;
    font-size:0.85rem;
    color: rgba(255,200,230,0.6);
  }

  @media (max-width:520px){
    h1{ font-size:1.4rem; }
  }
</style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="overlay">
    <div class="glow" id="glow"></div>
    <h1>üíê Ch√∫c m·ª´ng ng√†y 20/10 üíê</h1>
    <div class="sub">G·ª≠i t·∫∑ng nh·ªØng ƒë√≥a hoa, g·ª≠i tr·ªçn y√™u th∆∞∆°ng</div>
    <div class="hint">(Ch·∫°m / click ƒë·ªÉ t√°i t·∫°o hi·ªáu ·ª©ng)</div>
  </div>

<script>
/* ========= Tr√°i tim t·ª´ c√°nh hoa (petal swarm) ========= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;

window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; init(); });

/* heart parametric function (standard heart) */
function heartXY(t, scale=1){
  const x = 16 * Math.pow(Math.sin(t),3);
  const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
  return { x: x * scale, y: -y * scale }; // invert y
}

/* build target points along heart outline & fill */
function buildHeartTargets(count, scale){
  const pts = [];
  // sample t densely, push target positions with some randomness
  const samples = Math.max(400, count*1.2|0);
  for(let i=0;i<samples;i++){
    const t = (i/samples) * Math.PI * 2;
    const p = heartXY(t, scale);
    pts.push({x:p.x, y:p.y});
  }
  // to create 'fill' (not only outline), generate interior points by lerping
  const targets = [];
  for(let i=0;i<count;i++){
    // pick a base sample and random radial shrink to place inside
    const s = pts[Math.floor(Math.random()*pts.length)];
    const shrink = 0.6 + Math.random()*0.4; // 0.6-1: more inside or rim
    targets.push({ x: s.x * shrink, y: s.y * shrink });
  }
  return targets;
}

/* Petal class */
class Petal {
  constructor(target){
    // spawn from random outer region
    this.x = Math.random()*W;
    this.y = H + Math.random()*200 + 50; // start below view
    this.vx = (Math.random()-0.5)*1.6;
    this.vy = - (1 + Math.random()*2.2);
    this.size = 4 + Math.random()*6; // petal size
    // color red-purple pastel
    const hue = 320 + Math.random()*40; // purple-pink range
    const light = 55 + Math.random()*20;
    this.color = `hsla(${hue},80%,${light}%,`;
    this.alpha = 0;
    this.alphaVel = 0.008 + Math.random()*0.01;
    this.target = target; // local coordinates (center at 0,0)
    // randomness to approach
    this.wob = Math.random()*0.6 - 0.3;
    this.arrived = false;
    // rotation and flutter
    this.rot = Math.random()*Math.PI*2;
    this.rotSpeed = (Math.random()-0.5)*0.06;
    // easing factor for approach
    this.ease = 0.02 + Math.random()*0.03;
  }

  update(center, beatScale){
    // if not close to target, move towards target position + center
    const tx = center.x + this.target.x * beatScale;
    const ty = center.y + this.target.y * beatScale;
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.hypot(dx,dy);

    // if far -> glide; if near -> settle with small jitter
    if(dist > 6){
      // combine current velocity and attraction
      this.vx += dx * this.ease * 0.02 + (Math.random()-0.5)*0.2;
      this.vy += dy * this.ease * 0.02 + (Math.random()-0.5)*0.2;
      this.x += this.vx;
      this.y += this.vy;
    } else {
      // settle, slight floating
      this.x = tx + Math.sin(this.rot*2)*1.2;
      this.y = ty + Math.cos(this.rot*2)*1.2;
      this.arrived = true;
    }

    // alpha approaches 1
    if(this.alpha < 1) this.alpha += this.alphaVel;
    // rotation
    this.rot += this.rotSpeed;
  }

  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rot);
    // petal shape: draw ellipse with gradient
    const g = ctx.createLinearGradient(-this.size, -this.size, this.size, this.size);
    g.addColorStop(0, this.color + (0.95) + ')');
    g.addColorStop(0.5, this.color + (0.55) + ')');
    g.addColorStop(1, 'rgba(255,255,255,0.02)');
    ctx.globalAlpha = Math.max(0.05, this.alpha*0.95);
    // subtle glow
    ctx.shadowColor = 'rgba(255,160,220,0.9)';
    ctx.shadowBlur = 8;
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(0, 0, this.size*0.9, this.size*1.4, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha = 1;
  }
}

/* falling tiny spark stars to add depth */
class Spark {
  constructor(){
    this.x = Math.random()*W;
    this.y = Math.random()*H;
    this.size = Math.random()*1.6 + 0.2;
    this.speed = 0.2 + Math.random()*0.8;
    this.alpha = 0.2 + Math.random()*0.6;
  }
  update(){
    this.y += this.speed;
    if(this.y > H){ this.y = -10; this.x = Math.random()*W; }
  }
  draw(ctx){
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,230,255,${this.alpha})`;
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fill();
  }
}

/* Init */
let petals = [];
let sparks = [];
let heartTargets = [];
let center = { x: W/2, y: H/2 - 30 };
let formed = false;
let beat = 0;

function init(){
  center = { x: W/2, y: H/2 - 30 };
  petals = [];
  sparks = [];
  const total = Math.max(600, Math.floor((W*H)/1500)); // scale with screen
  heartTargets = buildHeartTargets(total, Math.min(W,H)/60); // scale param
  // create petals with assigned targets
  for(let i=0;i<heartTargets.length;i++){
    const t = heartTargets[i];
    petals.push(new Petal({x:t.x, y:t.y}));
  }
  // create background sparks
  for(let i=0;i<160;i++) sparks.push(new Spark());
  // show glow
  document.getElementById('glow').style.opacity = 0;
  formed = false;
}
init();

/* animate */
let formTimer = 0;
function loop(){
  ctx.clearRect(0,0,W,H);

  // draw background subtle gradient circle glow behind heart
  const radial = ctx.createRadialGradient(center.x, center.y, 10, center.x, center.y, Math.max(W,H)/2);
  radial.addColorStop(0, 'rgba(255,150,210,0.06)');
  radial.addColorStop(0.25, 'rgba(200,120,180,0.03)');
  radial.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = radial;
  ctx.fillRect(0,0,W,H);

  // update & draw sparks (stars)
  for(let s of sparks){ s.update(); s.draw(ctx); }

  // heart formation: over time petals go to targets. after enough time, set formed=true
  formTimer += 1/60;
  const approachScale = formed ? 1 : Math.min(1, formTimer / 2.2); // ~2.2s to form

  // beat when formed
  if(formed){
    beat += 0.12;
  } else {
    beat += 0.06;
  }
  const beatScale = 1 + Math.sin(beat)*0.055 * (formed ? 1 : 0.5);

  // update each petal
  for(let p of petals){
    p.update(center, approachScale * beatScale);
    p.draw(ctx);
  }

  // after certain time, mark formed and show glow
  if(!formed && formTimer > 2.2){
    formed = true;
    document.getElementById('glow').style.opacity = 1;
  }

  requestAnimationFrame(loop);
}
loop();

/* click/tap to restart formation */
function restart(){
  // fling existing petals away slightly then rebuild targets
  formTimer = 0;
  formed = false;
  heartTargets = buildHeartTargets(petals.length, Math.min(W,H)/60);
  for(let i=0;i<petals.length;i++){
    const t = heartTargets[i];
    petals[i].target = {x:t.x, y:t.y};
    // respawn below for fresh approach
    petals[i].x = Math.random()*W;
    petals[i].y = H + Math.random()*200 + 50;
    petals[i].alpha = 0;
  }
  document.getElementById('glow').style.opacity = 0;
}
window.addEventListener('click', restart);
window.addEventListener('touchstart', restart);
</script>
</body>
</html>
